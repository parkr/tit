#!/usr/bin/ruby

require 'pp'

require 'rubygems'
require 'ftools'
require 'nokogiri'
require 'optparse'
require 'rest_client'
require 'time'  # heh.
require 'yaml'

$RCFILE = File.join(ENV["HOME"], ".titrc")
$username = nil
$password = nil

$cols = nil

$readers = [:public, :home, :mentions]
$writers = [:update]

$urls = {
  :public => "statuses/public_timeline.xml",
  :home => "statuses/home_timeline.xml",
  :mentions => "statuses/mentions.xml",
  :update => "statuses/update.xml"
}

def get_authz
  begin
    File.open($RCFILE, "r") do |rc|
      data = YAML.load(rc)
      $username = data["username"]
      $password = data["password"]
    end
  rescue Errno::ENOENT => e
    File.open($RCFILE, "w") do |rc|
      YAML.dump({
                  "username" => "<username>",
                  "password" => "<password>"
                }, rc)
    end
  end

  if $username.nil? or $username.eql? "<username>" or
      $password.nil? or $password.eql? "<password>"
    puts "Please fill in your username and password in #{$RCFILE}"
    exit -1
  end

  RestClient::Resource.new("https://#{$username}:#{$password}@twitter.com/")
end

def get_tits action
  Nokogiri::XML(get_authz[$urls[action]].get).xpath("//status").map do |xml|
    {
      :username => xml.at_xpath("./user/name").content,
      :userid => xml.at_xpath("./user/screen_name").content,
      :text => xml.xpath("./text").map { |n| n.content },
      :timestamp => Time.parse(xml.at_xpath("./created_at").content),
      :id => xml.at_xpath("./id").content.to_i,
      :geo => xml.at_xpath("./geo").instance_eval do
          unless children.empty?
            n, e = children[1].content.split.map { |s| s.to_f }
            "#{n.abs}#{n >= 0 ? 'N' : 'S'} #{e.abs}#{e >= 0 ? 'E' : 'W'}"
          end
      end
    }
  end
end

def update payload
  if payload["status"] == STDIN
    payload["status"] = STDIN.read
  end

  if payload["status"].length > 140
    puts "your status is too long (by #{payload["status"].length - 140} characters)"
    puts "here is what would get posted:"
    payload["status"][0...140].wrapped($cols - 2).each { |l| puts "  #{l}" }
    exit -1
  end

  response = get_authz[$urls[:update]].post payload
end

class String
  def wrapped cols
    curlen = 0
    split.inject([[]]) do |rows, word|
      if curlen + word.length > cols
        curlen = word.length + 1
        rows << [word]
      else
        curlen += word.length + 1
        rows << (rows.pop << word)
      end
    end.map { |row| row.join ' ' }
  end
end

class Time
  def time_ago_in_words
    t = Time.now
    secs = t - self
    minutes = secs / 60
    hours = minutes / 60
    days = hours / 24
    if hours <= 12  # show a fuzzy time
      if hours > 2
        "#{hours.to_i} hours ago"
      elsif hours > 1
        "about an hour ago"
      elsif minutes > 2
        "#{minutes.to_i} minutes ago"
      elsif minutes > 1
        "about a minute ago"
      else
        "just now"
      end
    elsif days <= 15  # show time ago in days, with time if it was yesterday or today
      if t.day == day
        "today at #{strftime("%X")}"
      elsif t.day - day == 1
        "yesterday at #{strftime("%X")}"
      else
        "#{days.to_i} days ago"
      end
    else  # time in months or years
      months = t.month - month + (t.year - year) * 12
      if months <= 6
        if months == 1
          "last month"
        elsif t.year == year
          "this #{strftime("%B")}"
        else
          "last #{strftime("%B")}"
        end
      else
        if t.year - year == 1
          "last year"
        else
          "#{t.year - year} years ago"
        end
      end
    end
  end
end

def show_tit status
  puts(if status[:userid].eql? $username
         "you"
       else
         "#{status[:username]} (#{status[:userid]})"
       end + " said, #{status[:timestamp].time_ago_in_words}" +
       unless status[:geo].nil?
         ", from #{status[:geo]}:"
       else
         ":"
       end)

  status[:text].each do |line|
    line.wrapped($cols - 2).each { |l| puts "  #{l}" }
  end
  puts ""
end

def poll wait, action, notify
  tits = {}
  get_tits(action).reverse.each do |status|
    show_tit status
    tits[status[:id]] = status
  end
  last_update = Time.now()
  loop do
    print "\r", " " * (s = "Last update was at #{last_update.strftime "%X"}, " +
                       "next update at #{(last_update + wait).strftime "%X"}"
                       print s
                       STDOUT.flush
                       sleep wait
                       s.length), "\r"
    begin
      num_tits = get_tits(action).reverse.select do |status|
        not tits.include? status[:id]
      end.each_with_index do |status, i|
        if i == 0
          puts "more updates (at #{Time.now.strftime "%X"}):\n"
        end
        show_tit status
        tits[status[:id]] = status
      end.length
      %x[#{notify} '#{num_tits} new tits!'] unless notify.nil? or num_tits == 0
      last_update = Time.now()
    rescue SocketError, Errno::ENETUNREACH, Errno::ETIMEDOUT, RestClient::Exception => e
      puts "networking error, will try again later"
    end
  end
end

def error msg
  puts "#{File.basename $0}: #{msg}"
end

$opts = nil

def abort msg
  error msg
  puts $opts
  exit -1
end

def main
  options = {
    :action => :home,
    :wait => nil,
    :payload => nil,
    :notify => nil
  }

  $opts = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename($0)} " +
      "[options] [action [action options]]"

    opts.separator ""
    opts.separator "Actions:"

    opts.on("-p", "--public", "Show public timeline") do
      options[:action] = :public
    end
    opts.on("-H", "--home", "Show home timeline (default)") do
      options[:action] = :home
    end
    opts.on("-m", "--mentions", "Show mentions timeline") do
      options[:action] = :mentions
    end
    opts.on("-u", "--update [STATUS]",
            "Update status (read from STDIN if none given)") do |status|
      options[:action] = :update
      options[:payload] ||= {}
      options[:payload]["status"] = status || STDIN
    end

    opts.separator ""
    opts.separator "Receive options (public/home/mentions):"

    opts.on("-P", "--poll [N]",
            "Poll for more updates every N secs (default 180)") do |secs|
      options[:wait] = secs || '180'
      options[:wait] = options[:wait].to_i
      options[:wait] = 30 if options[:wait] < 30
    end

    opts.separator ""
    opts.separator "Poll options:"

    opts.on("-n", "--notify [PROG]",
            "Send notifications using PROG (default: notify-send)") do |prog|
      options[:notify] = prog || "notify-send"
    end

    opts.separator ""
    opts.separator "Update options:"

    opts.on("-G", "--geo LAT:LONG",
            "Set latitude and longitude for update") do |s|
      sp = s.split ":"

      abort("invalid geotag format: #{s}", opts) unless sp.length == 2

      options[:payload] ||= {}
      options[:payload]["lat"] = sp[0]
      options[:payload]["long"] = sp[1]
    end

    opts.separator ""
    opts.separator "Common options:"

    opts.on_tail("-h", "--help", "Show this message") do
      puts opts
      exit
    end
  end

  begin
    $opts.parse!
  rescue OptionParser::InvalidOption => e
    abort e.message
  end

  # check for option errors
  if $readers.include? options[:action]
    abort "cannot provide geotag when reading" unless options[:payload].nil?
    abort "cannot notify unless polling" if (options[:wait].nil? and
                                             not options[:notify].nil?)
  end
  if options[:action] == :update
    abort "need status message" unless options[:payload].include? "status"
    abort "can't repeatedly update status" unless options[:wait].nil?
    abort "can't notify when updating status" unless options[:notify].nil?
  end

  # set up proxy
  RestClient.proxy = ENV['https_proxy']

  # get terminal width
  $cols = %x[tput cols].to_i

  # do it
  begin
    if $readers.include? options[:action]
      if options[:wait].nil?
        get_tits(options[:action]).reverse.each &method(:show_tit)
      else
        poll options[:wait], options[:action], options[:notify]
      end
    elsif options[:action] == :update
      update options[:payload]
    end
  rescue SocketError, Errno::ENETUNREACH, Errno::ETIMEDOUT, RestClient::Exception => e
    error "got a networking error, are you connected to the intarbutts?"
    puts e
    exit -1
  rescue => e
    error "unknown error"
    puts e
    exit -1
  end
end

if $0 == __FILE__
  begin
    main
  rescue Interrupt
    puts ""
    exit 130
  end
end
